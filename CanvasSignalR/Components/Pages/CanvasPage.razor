@page "/canvas/{CanvasName}"
@inject NavigationManager Navigation
@rendermode InteractiveServer
@using CanvasSignalR.Models
@using Microsoft.AspNetCore.SignalR.Client

<PageTitle>Canvas: @CanvasName</PageTitle>

<div class="canvas-page">
    <div class="page-header">
        <div class="header-content">
        <h1>🎨 @CanvasName</h1>
 <p class="canvas-subtitle">Collaborative Drawing Canvas</p>
        </div>
        <button @onclick="Leave" class="leave-btn">← Leave Canvas</button>
    </div>

    <div class="canvas-container">
        <div class="canvas-wrapper">
       <canvas @ref="canvasRef" 
     width="800"
          height="600"
  @onmousedown="StartDrawing"
  @onmouseup="StopDrawing"
     @onmousemove="OnMouseMove"
@onmouseleave="StopDrawing"
    class="drawing-canvas"></canvas>
 </div>

        <div class="chat-panel">
            <div class="chat-header">
       <h4>💬 Chat</h4>
     <span class="chat-badge">Live</span>
     </div>
          
            <div @ref="chatContainerRef" class="chat-messages">
     @if (chatMessages.Count == 0)
       {
   <div class="empty-chat">
          <p>👋 No messages yet</p>
         <p class="empty-subtitle">Start a conversation!</p>
            </div>
  }
           else
{
   @foreach (var msg in chatMessages)
                {
    <div class="chat-message @(msg.User == "You" ? "own-message" : "")">
      <div class="message-header">
      <strong class="message-user">@msg.User</strong>
        <span class="message-time">@msg.Timestamp.ToString("HH:mm:ss")</span>
     </div>
<div class="message-content">@msg.Message</div>
    </div>
             }
    }
         </div>
     
            <div class="chat-input-container">
       <input @bind="messageInput" 
      @bind:event="oninput"
      @onkeypress="HandleKeyPress"
 placeholder="Type a message..." 
          class="chat-input" />
      <button @onclick="SendMessage" 
   disabled="@string.IsNullOrWhiteSpace(messageInput)"
         class="send-btn">
               Send →
       </button>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter]
    public string CanvasName { get; set; }
    private HubConnection hubConnection;

    private bool hasJoined = false;

    // Chat-related fields
    private List<ChatMessage> chatMessages = new();
    private string messageInput = string.Empty;
    private ElementReference chatContainerRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !hasJoined)
        {
            hubConnection = new HubConnectionBuilder()
     .WithUrl(Navigation.ToAbsoluteUri("/canvasHub"))
     .Build();
       await hubConnection.StartAsync();
         await hubConnection.InvokeAsync("JoinCanvas", CanvasName);
        hasJoined = true;

          hubConnection.On<int, int, int, int, string, int>("ReceiveCanvasUpdate", async (x1, y1, x2, y2, color, penSize) =>
         {
     await DrawLine(x1, y1, x2, y2, color, penSize);
   });

            hubConnection.On<string, string>("ReceiveMessage", async (userId, message) =>
{
        await InvokeAsync(() =>
        {
           chatMessages.Add(new ChatMessage
   {
         User = $"User-{userId.Substring(0, 8)}",
     Message = message,
  Timestamp = DateTime.Now
      });
   StateHasChanged();
                });
  });

    List<LineCommand> loadedCanvas = await hubConnection.InvokeAsync<List<LineCommand>>("GetCanvasCommands", CanvasName);
            foreach (var command in loadedCanvas)
    {
            await DrawLine(command.X1, command.Y1, command.X2, command.Y2, command.Color, command.PenSize);
  }
   }
    }

    public async Task Leave()
    {
        await hubConnection.InvokeAsync("LeaveCanvas", CanvasName);
     Navigation.NavigateTo("/");
    }

    private async Task SendMessage()
  {
        if (!string.IsNullOrWhiteSpace(messageInput) && hubConnection is not null)
        {
          // Add own message to the chat
   chatMessages.Add(new ChatMessage
       {
   User = "You",
 Message = messageInput,
          Timestamp = DateTime.Now
       });

            // Send to others via SignalR
            await hubConnection.InvokeAsync("SendMessage", CanvasName, messageInput);
     
            messageInput = string.Empty;
       StateHasChanged();
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
if (e.Key == "Enter")
        {
 await SendMessage();
   }
    }

    @inject IJSRuntime JS
    private ElementReference canvasRef;

    private bool isDrawing = false;
    private int lastX, lastY;

    private async Task StartDrawing(MouseEventArgs e)
    {
     isDrawing = true;
lastX = (int)e.OffsetX;
        lastY = (int)e.OffsetY;
    }

    private async Task StopDrawing()
    {
        isDrawing = false;
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (!isDrawing) return;

 int currentX = (int)e.OffsetX;
        int currentY = (int)e.OffsetY;

  await DrawLine(lastX, lastY, currentX, currentY, "#000000", 10);

        lastX = currentX;
   lastY = currentY;
    }

    private async Task DrawLine(int x1, int y1, int x2, int y2, string color, int penSize)
    {
        await JS.InvokeVoidAsync("drawLine", canvasRef, x1, y1, x2, y2, color, penSize);
        await hubConnection.InvokeAsync("SendLine", CanvasName, x1, y1, x2, y2, color , penSize);
    }

    private class ChatMessage
    {
        public string User { get; set; }
    public string Message { get; set; }
 public DateTime Timestamp { get; set; }
    }
}